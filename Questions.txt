1. Какой самый эффективный способ конкатенации строк?
Т.к строки неизменяемы, то при "обычном" сложении строк как "1234"+"5678" под результат будет выделен новый участок памяти, размером с эти 2 строки, и 
содержащий их сумму. Но если таких сложений нужно сделать много, то каждый раз под каждую отдельную операцию будет выделяться новый участок памяти, 
теряем в скорости работы. 
Строки лучше складывать схожим способом с тем, что есть в Java: strings.Builder, далее сложить строки WriteString.

2. Что такое интерфейсы, как они применяются в Go?
Интерфейсы - "правила" для структуры, "соблюдая" которые структура обязуется реализовать все методы из представленных в интерфейсе. 
В отличие от ООП языков в Go нет явного "наследования" от интерфейса. Структура, имеющая доступ к интерфейсу и реализовавшая его методы,
автоматически становится поддерживающей данный интерфейс.

3. Чем отличаются RWMutex от Mutex?
Типами блокировки. Mutex имеет общую блокировку Lock() и общую разблокировку Unlock(). 
RWMutex - это блокировка взаимного исключения чтения и записи. Т.е имеется отдельно блокировка на чтение, и блокировка на запись.
Блокировка может удерживаться произвольным количеством считывателей или одним записывающим устройством. Таким образом, например, нескольким
горутинам, которым нужно только считать данные, не нужно ждать друг друга. Им нужно ждать только тех, кто данные записывает.


4. Чем отличаются буферизированные и не буферизированные каналы?
Буферизированный канал имеет заданную ёмкость, и не будет блокировать записывающие в него данные, пока не заполнится полностью.
Небуферизированный канал может хранить только одно значение, и блокирует все остальные записи в него до тех пор, пока значение не будет считано.

5. Какой размер у структуры struct{}{}?
0 байт. (но непонятно что передаётся в канал при отправке в него struct{}{})

6. Есть ли в Go перегрузка методов или операторов?
Нет. 

7. В какой последовательности будут выведены элементы map[int]int?
Пример:
m[0]=1
m[1]=124
m[2]=281
В данном случае вывод будет как будто в порядке записи: map[0:1 1:124 2:281]
Но map не обязательно хранит данные в том порядке, в котором они были туда записаны (а fmt.Println сортирует вывод по ключам), поэтому для следующего примера
myMap[100] = struct{}{}
myMap[101] = struct{}{}
myMap[1] = struct{}{}
Вывод будет в отсортированном виде: map[1:{} 100:{} 101:{}]

8. В чем разница make и new?
make используется исключительно для создания и инициализации срезов, отображений и каналов, возвращает ненулевой экземпляр указанного типа
new инициализирует нулевое значение для данного типа и возвращает указатель на этот тип

9. Сколько существует способов задать переменную типа slice или map?
4:

s := []string{} //1
s = make([]string, "123", "456") //2
var s []string //3
arr := [2]string{"123", "456"}
s = arr[0:2] //4

m := map[string]struct{}{} //1        
m = make(map[string]struct{})     //2
m = make(map[string]struct{}, 5)  //3
var m map[string]struct{}     //4


10. Что выведет данная программа и почему?
func update(p *int) {
b := 2
p = &b
}
func main() {
var (
a = 1
p = &a
)
fmt.Println(*p)
update(p)
fmt.Println(*p)
}

Вывод: 
1
1
Первый вывод - вывод значения а. В функции update изменился адрес, на который указывает указатель p (в функции update), который является копией указателя p
в функции main, и потому исходный указатель не изменился (в Go value-семантика). Поэтому после вызова функции update адрес, на который указывал указатель p не изменился, и всё ещё
указывает на "а".

11. Что выведет данная программа и почему?
func main() {
wg := sync.WaitGroup{}
for i := 0; i < 5; i++ {
wg.Add(1)
go func(wg sync.WaitGroup, i int) {
fmt.Println(i)
wg.Done()
}(wg, i)
}
wg.Wait()
fmt.Println("exit")
}

Хаотичный вывод цифр от 0 до 4, затем deadlock. Копия wg, переданная по значению в горутину, после wg.Done() уменьшает свой счётчик, но счётчик оригинальной 
wg в main остаётся неизменным. Программа блокируется.


12. Что выведет данная программа и почему?
func main() {
n := 0
if true {
n := 1
n++
}
fmt.Println(n)
}

Вывод:
0
В этом коде в локальной области видимости оператора if была создана новая переменная n, перекрывшая область видимости переменной с таким же именем в main функции

13. Что выведет данная программа и почему?
func someAction(v []int8, b int8) {
v[0] = 100
v = append(v, b)
}
func main() {
var a = []int8{1, 2, 3, 4, 5}
someAction(a, 6)
fmt.Println(a)
}

Вывод: [100 2 3 4 5]
Т.к массив передаётся по указателю, то в строке v[0] = 100 мы изменяем первый элемент слайса. 
Но т.к у нас всё ещё value-семантика, то указатель v в someAction является копией указателя a в main, поэтому v = append(v, b) не приводит к изменению 
оригинального слайса, т.к изменён адрес на который указывала копия исходного указателя.


14. Что выведет данная программа и почему?
func main() {
slice := []string{"a", "a"}
func(slice []string) {
slice = append(slice, "a")
slice[0] = "b"
slice[1] = "b"
fmt.Print(slice)
}(slice)
fmt.Print(slice)
}

Вывод: [b b a][a a]
В анонимную функцию передан указатель на исходный slice, копии которого в функции присвоено новое значение, в виде суммы значения slice, и дополнительной
строки "а". Далее изменяется уже новый slice в области видимости анонимной функции, после чего выводится его значение: [b b a]
После завершения анонимной функции выводится значение исходного slice, который не был изменен (всё ещё value-семантика, всё ещё параметры передаются по значению)
